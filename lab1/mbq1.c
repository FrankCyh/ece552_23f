// This microbenchmark is used to test the RAW hazard of processor 1 in the lab handout.
// It's built and tested with -O2 optimization.
// The assembly code is generated by compiling with -S flag and is appended to the end of each line of C code and the end of the file.

int main(void) {
    int a = 0;  // create local variable
    int b = 0;

    while (a < 100000000) {
        // Loop condition check:
        // slt $2, $5, $3
        // beq $2, $0, $L4
        // This loop condition check actually creates a RAW hazard, because $2 is written in the first instruction and read in the second instruction.

        // Update the value of a, which is a write to `a`
        a++;  // addu	$3,$3,1

        // This `nop` is independent of the two instructions above and below.
        // By including or commenting out this nop, we can make this a 1-cycle stall or 2-cycle stall
        asm("nop");

        // Update the value of b, which is a read of `a`
        b = b + a;  // addu	$4,$4,$3
    }

    return a + b;  // must include this, otherwise the compiler will optimize out b variable
}

/* Assembly when including the nop
$L4:
    addu	$3,$3,1
#APP
    nop
#NO_APP
    addu	$4,$4,$3
    slt	$2,$5,$3
    beq	$2,$0,$L4


Stats from SimpleScalar sim-safe:
sim_num_insn              500006328 # total number of instructions executed
sim_num_raw_q1_1_cycle    100000082 # total number of 1 cycles stall
sim_num_raw_q1_2_cycle    100000858 # total number of 2 cycles stall
sim_num_RAW_hazard_q1     200000940 # total number of RAW hazards (q1)
CPI_from_RAW_hazard_q1       1.6000 # CPI from RAW hazard (q1)

With nop, we are producing one 1-cycles stalls and one 2-cycle stall in each iteration. 1-cycles stall is from `a++;` followed by `asm("nop");` and then `b = b + a;`. `asm("nop");`, reducing the original 2-cycle stall to 1-cycle stall. 2-cycle stall is from `slt $2, $5, $3` followed by `beq $2, $0, $L4`.
So in a total of 100000000 iteration, we can see 100000000 1-cycle stalls and 100000000 2-cycle stalls.
*/


/* Assembly when excluding the nop
$L4:
    addu	$3,$3,1
    addu	$4,$4,$3
    slt	$2,$5,$3
    beq	$2,$0,$L4


Stats from SimpleScalar sim-safe:
sim_num_insn              400006333 # total number of instructions executed
sim_num_raw_q1_1_cycle           83 # total number of 1 cycles stall
sim_num_raw_q1_2_cycle    200000858 # total number of 2 cycles stall
sim_num_RAW_hazard_q1     200000941 # total number of RAW hazards (q1)
CPI_from_RAW_hazard_q1       2.0000 # CPI from RAW hazard (q1)

Without nop, we are producing two 2-cycles stalls in each iteration, one from `a++;` followed by `b = b + a;`, and the other from `slt $2, $5, $3` followed by `beq $2, $0, $L4`.
So in a total of 100000000 iteration, we can see 200000000 2-cycle stalls.
 */